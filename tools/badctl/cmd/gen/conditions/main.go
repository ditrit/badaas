package conditions

import (
	"errors"
	"fmt"
	"go/types"
	"os"
	"path/filepath"

	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"golang.org/x/tools/go/packages"

	"github.com/ditrit/badaas/tools/badctl/cmd/cmderrors"
	"github.com/ditrit/badaas/tools/badctl/cmd/log"
	"github.com/ditrit/badaas/tools/badctl/cmd/version"
	"github.com/ditrit/verdeter"
)

var GenConditionsCmd = verdeter.BuildVerdeterCommand(verdeter.VerdeterConfig{
	Use:   "conditions",
	Short: "Generate conditions to query your objects using BaDORM",
	Long:  `gen is the command you can use to generate the files and configurations necessary for your project to use BadAss in a simple way.`,
	Run:   generateConditions,
	Args:  cobra.MinimumNArgs(1),
})

const (
	DestPackageKey                  = "dest_package"
	badORMVerifyStructLoaded        = "VerifyStructLoaded"
	badORMVerifyPointerLoaded       = "VerifyPointerLoaded"
	badORMVerifyPointerWithIDLoaded = "VerifyPointerWithIDLoaded"
)

func init() {
	err := GenConditionsCmd.LKey(
		DestPackageKey, verdeter.IsStr, "d",
		"Destination package (not used if ran with go generate)",
	)
	if err != nil {
		cmderrors.FailErr(err)
	}
}

// GenConditionsCmd Run func
func generateConditions(_ *cobra.Command, args []string) {
	log.SetLevel()
	// Inspect package and use type checker to infer imported types
	pkgs := loadPackages(args)

	// Get the package of the file with go:generate comment or in command params
	destPkg := os.Getenv("GOPACKAGE")
	if destPkg == "" {
		destPkg = viper.GetString(DestPackageKey)
		if destPkg == "" {
			cmderrors.FailErr(errors.New("config --dest_package or use go generate"))
		}
	}

	// Generate conditions for each package
	for i, pkg := range pkgs {
		generateConditionsForPkg(destPkg, args[i], pkg)
	}
}

// Generates a file with conditions for each BaDORM model in the package
func generateConditionsForPkg(destPkg string, pkgPath string, pkg *packages.Package) {
	log.Logger.Infof("Generating conditions for types in package %q", pkg.Types.Name())

	// TODO codigo repetido con file
	// Start a new file in destination package
	f := jen.NewFile(pkg.Types.Name())
	// Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by badctl v" + version.Version + ", DO NOT EDIT.")

	relationGetters := []jen.Code{}

	for _, name := range pkg.Types.Scope().Names() {
		object := getObject(pkg, name)
		if object != nil {
			file, err := NewConditionsFile(
				destPkg,
				strcase.ToSnake(object.Name())+"_conditions.go",
				object,
			)
			if err != nil {
				// object is not a BaDORM model, do not generate conditions
				continue
			}

			err = file.Save()
			if err != nil {
				cmderrors.FailErr(err)
			}

			relationGettersForObject := generateRelationGetters(object)
			relationGetters = append(relationGetters, relationGettersForObject...)
		}
	}

	// TODO codigo repetido con file
	if len(relationGetters) > 0 {
		for _, relationGetter := range relationGetters {
			f.Add(relationGetter)
		}
		// f.Add(relationGetters...)
		err := f.Save(filepath.Join(pkgPath, "badorm.go"))
		if err != nil {
			cmderrors.FailErr(err)
		}
	}
}

func generateRelationGetters(object types.Object) []jen.Code {
	// TODO codigo repetido con file
	objectType := Type{object.Type()}
	fields, _ := getFields(objectType)
	relationGetters := []jen.Code{}

	for _, field := range fields {
		if field.Embedded {
			// TODO
		} else {
			// TODO codigo repetido con condition.go
			switch fieldType := field.GetType().(type) {
			case *types.Named:
				// the field is a named type (user defined structs)
				_, err := field.Type.BadORMModelStruct()

				if err == nil {
					// field is a BaDORM Model
					relationGetters = append(
						relationGetters,
						generateVerifyStruct(object, field),
					)
				}
			case *types.Pointer:
				// the field is a pointer
				_, err := field.ChangeType(fieldType.Elem()).Type.BadORMModelStruct()

				if err == nil {
					// field is a BaDORM Model
					fk, err := objectType.GetFK(field)
					if err != nil {
						log.Logger.Debugf("unhandled: field is a pointer and object not has the fk: %T", fieldType)
						continue
					}

					switch fk.GetType().(type) {
					// TODO verificar que sea de los ids correctos?
					// TODO basics para strings y eso?
					case *types.Named:
						relationGetters = append(
							relationGetters,
							generateVerifyPointerWithID(object, field),
						)
					case *types.Pointer:
						relationGetters = append(
							relationGetters,
							generateVerifyPointer(object, field),
						)
					}
				}
			default:
				log.Logger.Debugf("struct field type not handled: %T", fieldType)
			}
		}
	}

	return relationGetters
}

func getGetterName(field Field) string {
	return "Get" + strcase.ToPascal(field.Name)
}

func generateVerifyStruct(object types.Object, field Field) *jen.Statement {
	return generateGetterCommon(
		object,
		field,
		badORMVerifyStructLoaded,
		jen.Op("&").Id("m").Op(".").Id(field.Name),
	)
}

func generateVerifyPointer(object types.Object, field Field) *jen.Statement {
	return generateVerifyPointerCommon(object, field, badORMVerifyPointerLoaded)
}

func generateVerifyPointerWithID(object types.Object, field Field) *jen.Statement {
	return generateVerifyPointerCommon(object, field, badORMVerifyPointerWithIDLoaded)
}

func generateVerifyPointerCommon(object types.Object, field Field, verifyFunc string) *jen.Statement {
	return generateGetterCommon(
		object,
		field,
		verifyFunc,
		jen.Id("m").Op(".").Id(field.Name+"ID"),
		jen.Id("m").Op(".").Id(field.Name),
	)
}

func generateGetterCommon(object types.Object, field Field, verifyFunc string, callParams ...jen.Code) *jen.Statement {
	return jen.Func().Parens(
		jen.Id("m").Id(object.Name()),
	).Id(getGetterName(field)).Params().Add(
		jen.Parens(
			jen.List(
				jen.Op("*").Qual(
					getRelativePackagePath(
						object.Pkg().Name(),
						field.Type,
					),
					field.TypeName(),
				),

				jen.Id("error"),
			),
		),
	).Block(
		jen.Return(
			jen.Qual(
				badORMPath,
				verifyFunc,
			).Types(
				jen.Id(field.TypeName()),
			).Call(
				callParams...,
			),
		),
	)
}

// Load package information from paths
func loadPackages(paths []string) []*packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes}

	pkgs, err := packages.Load(cfg, paths...)
	if err != nil {
		cmderrors.FailErr(fmt.Errorf("loading packages for inspection: %w", err))
	}

	// print compilation errors of source packages
	packages.PrintErrors(pkgs)

	return pkgs
}

// Get object by name in the package
func getObject(pkg *packages.Package, name string) types.Object {
	obj := pkg.Types.Scope().Lookup(name)
	if obj == nil {
		cmderrors.FailErr(fmt.Errorf("%s not found in declared types of %s",
			name, pkg))
	}

	// Generate only if it is a declared type
	object, ok := obj.(*types.TypeName)
	if !ok {
		return nil
	}

	return object
}
