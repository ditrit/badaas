package conditions

import (
	"errors"
	"go/types"
	"log"

	"github.com/dave/jennifer/jen"
	"github.com/ditrit/badaas/tools/badctl/cmd/version"
	"github.com/elliotchance/pie/v2"
)

type File struct {
	destPkg string
	jenFile *jen.File
	name    string
}

func NewConditionsFile(destPkg string, name string) *File {
	// Start a new file in destination package
	f := jen.NewFile(destPkg)

	// Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by badctl v" + version.Version + ", DO NOT EDIT.")

	return &File{
		destPkg: destPkg,
		name:    name,
		jenFile: f,
	}
}

func (file File) AddConditionsFor(object types.Object) error {
	// Generate only when underlying type is a struct
	// (ignore const, var, func, etc.)
	structType, err := getBadORMModelStruct(object.Type())
	if err != nil {
		return err
	}

	fields, err := getFields(structType, "")
	if err != nil {
		return err
	}

	file.addConditionsForEachField(object, fields)
	return nil
}

func (file File) addConditionsForEachField(object types.Object, fields []Field) {
	conditions := generateConditionsForEachField(object, fields)

	for _, condition := range conditions {
		// TODO esto no me gusta mucho que este aca
		for _, code := range condition.codes {
			file.jenFile.Add(code)
		}
	}
}

// Write generated file
func (file File) Save() error {
	return file.jenFile.Save(file.name)
}

// badorm/baseModels.go
var badORMModels = []string{"UUIDModel", "UIntModel"}

const (
	badORMPath = "github.com/ditrit/badaas/badorm"
	// badorm/condition.go
	badORMCondition      = "Condition"
	badORMWhereCondition = "WhereCondition"
	badORMJoinCondition  = "JoinCondition"
)

func generateConditionsForEachField(object types.Object, fields []Field) []*Condition {
	conditions := []*Condition{}
	for _, field := range fields {
		log.Println(field.Name)
		if field.Embedded {
			conditions = append(conditions, generateEmbeddedConditions(
				object,
				field,
			)...)
		} else {
			conditions = append(conditions, NewCondition(
				object.Type(), field,
			))
		}
	}

	return conditions
}

func getBadORMModelStruct(typeV types.Type) (*types.Struct, error) {
	structType, ok := typeV.Underlying().(*types.Struct)
	if !ok || !isBadORMModel(structType) {
		return nil, errors.New("object is not a BaDORM model")
	}

	return structType, nil
}

func isBadORMModel(structType *types.Struct) bool {
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)

		if field.Embedded() && pie.Contains(badORMModels, field.Name()) {
			return true
		}
	}

	return false
}

// TODO quizas esto no deberia estar aca
func generateEmbeddedConditions(object types.Object, field Field) []*Condition {
	embeddedFieldType, ok := field.Type.(*types.Named)
	if !ok {
		failErr(errors.New("unreachable! embedded objects are always of type Named"))
	}
	embeddedStructType, ok := embeddedFieldType.Underlying().(*types.Struct)
	if !ok {
		failErr(errors.New("unreachable! embedded objects are always structs"))
	}

	fields, err := getFields(embeddedStructType, field.Tags.getEmbeddedPrefix())
	if err != nil {
		// TODO ver esto
		return []*Condition{}
	}

	return generateConditionsForEachField(object, fields)
}
