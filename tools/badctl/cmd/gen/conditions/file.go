package conditions

import (
	"errors"
	"go/types"

	"github.com/dave/jennifer/jen"
	"github.com/elliotchance/pie/v2"

	"github.com/ditrit/badaas/tools/badctl/cmd/cmderrors"
	"github.com/ditrit/badaas/tools/badctl/cmd/log"
	"github.com/ditrit/badaas/tools/badctl/cmd/version"
)

const (
	badORMPath                = "github.com/ditrit/badaas/badorm"
	badORMNewPreloadCondition = "NewPreloadCondition"
)

type File struct {
	destPkg    string
	jenFile    *jen.File
	name       string
	object     types.Object
	objectType Type
}

func NewConditionsFile(destPkg string, name string, object types.Object) (*File, error) {
	// Start a new file in destination package
	f := jen.NewFile(destPkg)

	// Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by badctl v" + version.Version + ", DO NOT EDIT.")

	file := &File{
		destPkg:    destPkg,
		name:       name,
		jenFile:    f,
		object:     object,
		objectType: Type{object.Type()},
	}

	err := file.addConditions()
	if err != nil {
		return nil, err
	}

	return file, nil
}

// Add conditions for an object in the file
func (file File) addConditions() error {
	fields, err := getFields(file.objectType)
	if err != nil {
		return err
	}

	log.Logger.Infof("Generating conditions for type %q in %s", file.object.Name(), file.name)

	file.addConditionsForEachField(fields)

	return nil
}

// Add one condition for each field of the object
func (file File) addConditionsForEachField(fields []Field) {
	conditions := file.generateConditionsForEachField(fields)

	objectName := file.object.Name()
	objectQual := jen.Qual(
		getRelativePackagePath(file.destPkg, file.objectType),
		file.objectType.Name(),
	)
	preloadAttributesCondition := jen.Var().Id(
		getPreloadAttributesName(objectName),
	).Op("=").Add(jen.Qual(
		badORMPath, badORMNewPreloadCondition,
	)).Types(
		objectQual,
	)
	fieldIdentifiers := []jen.Code{}

	preloadAllCondition := jen.Var().Id(
		objectName + "PreloadRelations",
	).Op("=").Index().Add(jen.Qual(
		badORMPath, badORMCondition,
	)).Types(
		objectQual,
	)
	preloads := []jen.Code{}

	for _, condition := range conditions {
		for _, code := range condition.codes {
			file.jenFile.Add(code)
		}

		if condition.fieldIdentifier != "" {
			fieldIdentifiers = append(
				fieldIdentifiers,
				jen.Qual("", condition.fieldIdentifier),
			)
		}

		if condition.preloadName != "" {
			preloads = append(
				preloads,
				jen.Qual("", condition.preloadName),
			)
		}
	}

	file.jenFile.Add(preloadAttributesCondition.Call(fieldIdentifiers...))
	file.jenFile.Add(preloadAllCondition.Values(preloads...))
}

func getPreloadAttributesName(objectName string) string {
	return objectName + "PreloadAttributes"
}

// Write generated file
func (file File) Save() error {
	return file.jenFile.Save(file.name)
}

// Generate the conditions for each of the object's fields
func (file File) generateConditionsForEachField(fields []Field) []*Condition {
	conditions := []*Condition{}

	for _, field := range fields {
		log.Logger.Debugf("Generating condition for field %q", field.Name)

		if field.Embedded {
			conditions = append(conditions, file.generateEmbeddedConditions(
				field,
			)...)
		} else {
			conditions = append(conditions, NewCondition(
				file.destPkg, file.objectType, field,
			))
		}
	}

	return conditions
}

// Generate conditions for a embedded field
// it will generate a condition for each of the field of the embedded field's type
func (file File) generateEmbeddedConditions(field Field) []*Condition {
	embeddedStructType, ok := field.Type.Underlying().(*types.Struct)
	if !ok {
		cmderrors.FailErr(errors.New("unreachable! embedded objects are always structs"))
	}

	fields, err := getStructFields(embeddedStructType)
	if err != nil {
		// embedded field's type has not fields
		return []*Condition{}
	}

	if !isBadORMBaseModel(field.TypeString()) {
		fields = pie.Map(fields, func(embeddedField Field) Field {
			embeddedField.ColumnPrefix = field.Tags.getEmbeddedPrefix()
			embeddedField.NamePrefix = field.Name

			return embeddedField
		})
	}

	return file.generateConditionsForEachField(fields)
}
