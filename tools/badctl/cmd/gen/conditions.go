package gen

import (
	"errors"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/ditrit/verdeter"
	"github.com/elliotchance/pie/v2"
	"github.com/ettle/strcase"
	"github.com/spf13/cobra"

	"golang.org/x/tools/go/packages"
)

var genConditionsCmd = verdeter.BuildVerdeterCommand(verdeter.VerdeterConfig{
	Use:   "conditions",
	Short: "Generate conditions to query your objects using BaDORM",
	Long:  `gen is the command you can use to generate the files and configurations necessary for your project to use BadAss in a simple way.`,
	Run:   generateConditions,
	Args:  cobra.MinimumNArgs(1),
})

// badorm/baseModels.go
var badORMModels = []string{"UUIDModel", "UIntModel"}

func generateConditions(cmd *cobra.Command, args []string) {
	log.Println(args)

	// Inspect package and use type checker to infer imported types
	pkgs := loadPackages(args)

	for _, pkg := range pkgs {
		log.Println(pkg.Types.Path())
		log.Println(pkg.Types.Name())

		for _, name := range pkg.Types.Scope().Names() {
			structType := getStructType(pkg, name)
			if structType != nil && isBadORMModel(structType) {
				log.Println(name)

				// Generate code using jennifer
				err := generate(name, structType)
				if err != nil {
					failErr(err)
				}
			}
		}
	}
}

func getStructType(pkg *packages.Package, name string) *types.Struct {
	obj := pkg.Types.Scope().Lookup(name)
	if obj == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s",
			name, pkg))
	}

	// Generate only if it is a declared type
	if _, ok := obj.(*types.TypeName); !ok {
		return nil
	}
	// Generate only when underlying type is a struct
	// (ignore const, var, func, etc.)
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		return nil
	}

	return structType
}

func isBadORMModel(structType *types.Struct) bool {
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)

		// TODO quizas se puede hacer con el type en lugar del nombre
		if field.Embedded() && pie.Contains(badORMModels, field.Name()) {
			return true
		}
	}

	return false
}

func generate(structTypeName string, structType *types.Struct) error {
	// Get the package of the file with go:generate comment
	goPackage := os.Getenv("GOPACKAGE")
	if goPackage == "" {
		failErr(errors.New("this command should be called using go generate"))
	}

	// Start a new file in this package
	f := jen.NewFile(goPackage)

	// Add a package comment, so IDEs detect files as generated
	// TODO version configurable
	f.PackageComment("Code generated by badctl v0.0.0, DO NOT EDIT.")

	// Iterate over struct fields
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		// TODO tagValue := structType.Tag(i)

		log.Println(field.Name())
		generateConditionForField(f, structTypeName, field.Name(), field.Type())
	}

	// Build the target file name
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_" + strings.ToLower(structTypeName) + "_gen.go"

	// Write generated file
	return f.Save(targetFilename)
}

func generateConditionForField(f *jen.File, structName, fieldName string, fieldType types.Type) error {
	switch v := fieldType.(type) {
	case *types.Basic:
		generateWhereCondition(
			f, structName, fieldName,
			typeKindToJenStatement[v.Kind()],
		)
	case *types.Named:
		// typeName := v.Obj()
		log.Println("named")
		log.Println(v.String())
		// log.Println(typeName.String())
	// Qual automatically imports packages
	// code.Op("*").Qual(
	// typeName.Pkg().Path(),
	// typeName.Name(),
	// )
	case *types.Pointer:
		log.Println("pointer")
		if v.String() == "*github.com/google/uuid.UUID" {
			log.Println(v.String())
		} else {
			generateConditionForField(f, structName, fieldName, v.Elem())
		}
	// case *types.Slice:
	// log.Printf("slices not supported yet: %s.%s", structTypeName, field.Name())
	default:
		log.Printf("struct field type not hanled: %T", v)
	}

	return nil
}

var param = jen.Id("v")

var typeKindToJenStatement = map[types.BasicKind]*jen.Statement{
	types.Bool:       param.Clone().Bool(),
	types.Int:        param.Clone().Int(),
	types.Int8:       param.Clone().Int8(),
	types.Int16:      param.Clone().Int16(),
	types.Int32:      param.Clone().Int32(),
	types.Int64:      param.Clone().Int64(),
	types.Uint:       param.Clone().Uint(),
	types.Uint8:      param.Clone().Uint8(),
	types.Uint16:     param.Clone().Uint16(),
	types.Uint32:     param.Clone().Uint32(),
	types.Uint64:     param.Clone().Uint64(),
	types.Uintptr:    param.Clone().Uintptr(),
	types.Float32:    param.Clone().Float32(),
	types.Float64:    param.Clone().Float64(),
	types.Complex64:  param.Clone().Complex64(),
	types.Complex128: param.Clone().Complex128(),
	types.String:     param.Clone().String(),
}

func generateWhereCondition(f *jen.File, structName, fieldName string, param *jen.Statement) {
	whereCondition := jen.Qual(
		// TODO deberia tener el paquete pero solo si es el destino es un paquete distinto
		"github.com/ditrit/badaas/badorm", "WhereCondition["+strcase.ToPascal(structName)+"]",
	)
	f.Func().Id(
		strcase.ToPascal(structName) + strcase.ToPascal(fieldName) + "Condition",
	).Params(
		param,
	).Add(
		whereCondition.Clone(),
	).Block(
		jen.Return(
			whereCondition.Clone().Values(jen.Dict{
				// TODO gorm column redefinition
				jen.Id("Field"): jen.Lit(strcase.ToSnake(fieldName)),
				jen.Id("Value"): jen.Id("v"),
			}),
		),
	)
}

func loadPackages(paths []string) []*packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes}
	pkgs, err := packages.Load(cfg, paths...)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
